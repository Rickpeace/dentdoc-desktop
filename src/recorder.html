<!DOCTYPE html>
<html>
<head>
  <title>Audio Recorder</title>
</head>
<body>
  <script>
    const { ipcRenderer } = require('electron');

    let mediaRecorder = null;
    let audioChunks = [];
    let audioContext = null;
    let analyser = null;
    let animationId = null;

    ipcRenderer.on('start-recording', async () => {
      try {
        audioChunks = [];

        const stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            channelCount: 1,
            sampleRate: 16000,
            echoCancellation: true,
            noiseSuppression: true
          }
        });

        // Set up audio analysis
        audioContext = new AudioContext();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        const source = audioContext.createMediaStreamSource(stream);
        source.connect(analyser);

        // Start monitoring audio levels
        monitorAudioLevel();

        mediaRecorder = new MediaRecorder(stream, {
          mimeType: 'audio/webm;codecs=opus'
        });

        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
          }
        };

        mediaRecorder.onstop = async () => {
          const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
          const arrayBuffer = await audioBlob.arrayBuffer();
          ipcRenderer.send('recording-data', Array.from(new Uint8Array(arrayBuffer)));

          // Stop all tracks
          stream.getTracks().forEach(track => track.stop());

          // Stop audio analysis
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }
          if (audioContext) {
            audioContext.close();
            audioContext = null;
          }
        };

        mediaRecorder.start(1000); // Collect data every second
        console.log('Recording started');
      } catch (error) {
        console.error('Recording error:', error);
        ipcRenderer.send('recording-error', error.message);
      }
    });

    function monitorAudioLevel() {
      if (!analyser) return;

      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);

      const checkLevel = () => {
        analyser.getByteFrequencyData(dataArray);

        // Calculate average volume
        let sum = 0;
        for (let i = 0; i < bufferLength; i++) {
          sum += dataArray[i];
        }
        const average = sum / bufferLength;
        const normalized = average / 255; // Normalize to 0-1

        // Send to main process
        ipcRenderer.send('audio-level-update', normalized);

        animationId = requestAnimationFrame(checkLevel);
      };

      checkLevel();
    }

    ipcRenderer.on('stop-recording', () => {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
        console.log('Recording stopped');
      } else {
        ipcRenderer.send('recording-error', 'No active recording');
      }
    });
  </script>
</body>
</html>
