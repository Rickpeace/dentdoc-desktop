<!DOCTYPE html>
<html>
<head>
  <title>Audio Recorder</title>
</head>
<body>
  <script>
    const { ipcRenderer } = require('electron');

    let mediaRecorder = null;
    let audioChunks = [];
    let audioContext = null;
    let analyser = null;
    let animationId = null;
    let currentStream = null;

    /**
     * Robust audio stream acquisition with fallback cascade
     * 1. Try saved device ID (exact)
     * 2. Try saved device ID (preferred)
     * 3. Try default device
     * 4. Try any audio device
     */
    async function getAudioStream(savedDeviceId) {
      const errors = [];

      // Small delay to let USB devices initialize (helps with USB hubs)
      await new Promise(r => setTimeout(r, 300));

      // Get current device list
      let devices = [];
      try {
        devices = await navigator.mediaDevices.enumerateDevices();
        const audioDevices = devices.filter(d => d.kind === 'audioinput');
        console.log('Available audio devices:', audioDevices.map(d => ({ id: d.deviceId, label: d.label })));
      } catch (e) {
        console.warn('Could not enumerate devices:', e);
      }

      // Check if saved device still exists
      const savedDeviceExists = savedDeviceId && devices.some(d => d.deviceId === savedDeviceId);

      // Attempt 1: Saved device with exact constraint
      if (savedDeviceExists) {
        try {
          console.log('Attempt 1: Trying saved device (exact):', savedDeviceId);
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: {
              deviceId: { exact: savedDeviceId },
              channelCount: 1,
              sampleRate: { ideal: 16000 },
              echoCancellation: true,
              noiseSuppression: true
            }
          });
          console.log('Success: Got stream from saved device (exact)');
          return stream;
        } catch (e) {
          console.warn('Attempt 1 failed:', e.message);
          errors.push(`Saved device (exact): ${e.message}`);
        }
      }

      // Attempt 2: Saved device with preferred constraint (less strict)
      if (savedDeviceId) {
        try {
          console.log('Attempt 2: Trying saved device (preferred):', savedDeviceId);
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: {
              deviceId: { ideal: savedDeviceId },
              channelCount: 1,
              sampleRate: { ideal: 16000 },
              echoCancellation: true,
              noiseSuppression: true
            }
          });
          console.log('Success: Got stream from saved device (preferred)');
          return stream;
        } catch (e) {
          console.warn('Attempt 2 failed:', e.message);
          errors.push(`Saved device (preferred): ${e.message}`);
        }
      }

      // Attempt 3: Default device with constraints
      try {
        console.log('Attempt 3: Trying default device with constraints');
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            channelCount: 1,
            sampleRate: { ideal: 16000 },
            echoCancellation: true,
            noiseSuppression: true
          }
        });
        console.log('Success: Got stream from default device');
        return stream;
      } catch (e) {
        console.warn('Attempt 3 failed:', e.message);
        errors.push(`Default device: ${e.message}`);
      }

      // Attempt 4: Any audio device (minimal constraints)
      try {
        console.log('Attempt 4: Trying any audio device (minimal constraints)');
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: true
        });
        console.log('Success: Got stream with minimal constraints');
        return stream;
      } catch (e) {
        console.warn('Attempt 4 failed:', e.message);
        errors.push(`Any device: ${e.message}`);
      }

      // All attempts failed
      const errorMsg = `Kein Mikrofon verfÃ¼gbar. Versuche:\n${errors.join('\n')}`;
      throw new Error(errorMsg);
    }

    ipcRenderer.on('start-recording', async (event, options = {}) => {
      try {
        audioChunks = [];
        const savedDeviceId = options.deviceId || null;

        console.log('Starting recording, saved device:', savedDeviceId);

        // Get audio stream with robust fallback
        currentStream = await getAudioStream(savedDeviceId);

        // Set up audio analysis for level meter
        audioContext = new AudioContext();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        const source = audioContext.createMediaStreamSource(currentStream);
        source.connect(analyser);

        // Start monitoring audio levels
        monitorAudioLevel();

        // Create media recorder
        mediaRecorder = new MediaRecorder(currentStream, {
          mimeType: 'audio/webm;codecs=opus'
        });

        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
          }
        };

        mediaRecorder.onstop = async () => {
          const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
          const arrayBuffer = await audioBlob.arrayBuffer();
          ipcRenderer.send('recording-data', Array.from(new Uint8Array(arrayBuffer)));

          // Cleanup
          cleanup();
        };

        mediaRecorder.onerror = (event) => {
          console.error('MediaRecorder error:', event.error);
          ipcRenderer.send('recording-error', event.error?.message || 'MediaRecorder error');
          cleanup();
        };

        mediaRecorder.start(1000); // Collect data every second
        console.log('Recording started successfully');
        ipcRenderer.send('recording-started');

      } catch (error) {
        console.error('Recording error:', error);
        ipcRenderer.send('recording-error', error.message);
        cleanup();
      }
    });

    function monitorAudioLevel() {
      if (!analyser) return;

      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);

      const checkLevel = () => {
        if (!analyser) return;

        analyser.getByteFrequencyData(dataArray);

        // Use RMS (Root Mean Square) for better audio level representation
        let sumSquares = 0;
        let peak = 0;
        for (let i = 0; i < bufferLength; i++) {
          sumSquares += dataArray[i] * dataArray[i];
          if (dataArray[i] > peak) peak = dataArray[i];
        }
        const rms = Math.sqrt(sumSquares / bufferLength);

        // Combine RMS and peak for responsive meter (70% RMS, 30% peak)
        const combined = (rms * 0.7 + peak * 0.3);

        // Apply logarithmic scaling for more natural response
        // and boost low values to make meter more responsive
        const scaled = Math.pow(combined / 255, 0.6);
        const normalized = Math.min(1, scaled * 1.5); // Boost and clamp to 0-1

        // Send to main process
        ipcRenderer.send('audio-level-update', normalized);

        animationId = requestAnimationFrame(checkLevel);
      };

      checkLevel();
    }

    function cleanup() {
      // Stop animation
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }

      // Close audio context
      if (audioContext) {
        audioContext.close().catch(() => {});
        audioContext = null;
        analyser = null;
      }

      // Stop all tracks
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
        currentStream = null;
      }

      mediaRecorder = null;
    }

    ipcRenderer.on('stop-recording', () => {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
        console.log('Recording stopped');
      } else {
        ipcRenderer.send('recording-error', 'No active recording');
      }
    });

    // Handle window unload
    window.addEventListener('beforeunload', cleanup);
  </script>
</body>
</html>
